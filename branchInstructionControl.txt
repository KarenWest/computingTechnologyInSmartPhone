Now let's discuss a branch instruction, which has two states after decode.
Now, a branch depends on the value of BEN,
and we generate that value in the decode stage.
Now, here's how we generate that value.
Here's the equation for BEN.
First, we AND bit 11 with the N bit in the condition code register.
We also AND bit 10 with the Z bit and bit 9 with the P bit.
And then we OR those three ANDs together.
That's how we generate BEN.
And that tells us whether we have a match between our condition code
register and bits 11 through 9 in our instruction register.
Now, in the first branch state, we're going to evaluate that value, BEN,
that was generated in decode.
And we're either going to go back to instruction fetchâ€”
if that value is a 0, that indicates we have a not-taken branch--
that the condition was not met.
We go back to instruction fetch.
If that value is a 1, that means the condition is met,
and we need to change the PC from its incremented value.
That's the second state in the branch.
Here's the first state.
And, again, the BEN is generated by some logic that
looks at the N, Z, P bits in the condition code,
as well as the N, Z, P fields in the instruction
register, which is bits 11 through 9.
Now, if BEN is a 0, we're going to go back to instruction fetch.
If it's a 1, we're going to update the PC.
And here's how we do it.
We need to set the address 1 mux to take the PC value
and feed that to the adder.
We also take the rightmost 9 bits of the instruction,
we sign-extend those, and pass those through the second mux
to the second input of the adder.
Then we allow that value to pass to the PC mux
through the select inputs of that mux.
And finally we set the load PC signal to be a 1
so that we update the PC with the target value.
And then we'll go back to instruction fetch,
and we'll start reading instructions from that target location.